<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>ã‚«ãƒ¡ãƒ©ï¼‹æ‰‹æãï¼‹ã‚ºãƒ¼ãƒ ï¼‹æ˜ åƒèª¿æ•´ï¼‹é™æ­¢ç”»ï¼å‹•ç”»ï¼TLï¼‹ãªã’ãªã‚ï¼‹ã‚¹ãƒ†ãƒƒã‚«ãƒ¼ä¿å­˜</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: system-ui, -apple-system, BlinkMacSystemFont;
      background: #000;
      color: #fff;
    }
    #app {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    header {
      padding: 8px 12px;
      font-size: 14px;
      background: rgba(0,0,0,0.7);
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 5;
      position: relative;
    }
    header span.title {
      font-weight: 600;
    }
    #header-right {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    #camera-wrapper {
      position: relative;
      flex: 1;
      background: #000;
      overflow: hidden;
      touch-action: none;
    }
    #camera-inner {
      position: absolute;
      inset: 0;
      transform-origin: 0 0;
    }
    #video {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    #draw-layer,
    #ui-layer {
      position: absolute;
      inset: 0;
    }
    #draw-layer {
      touch-action: none;
    }
    #ui-layer {
      pointer-events: none; /* ã‚¹ãƒ†ãƒƒã‚«ãƒ¼æ“ä½œã‚„ãªã’ãªã‚æ™‚ã ã‘ JS ã‹ã‚‰ auto ã«åˆ‡ã‚Šæ›¿ãˆã‚‹ */
    }

    /* â–¼ ä¸‹ã®ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ */
    #toolbar {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 8px;
      transform: none;
      display: flex;
      flex-wrap: nowrap;
      justify-content: center;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      border-radius: 999px;
      background: rgba(0,0,0,0.75);
      backdrop-filter: blur(6px);
      z-index: 20;
      max-width: 100%;
      box-sizing: border-box;
    }
    .tool-btn {
      width: clamp(28px, 7vw, 40px);
      height: clamp(28px, 7vw, 40px);
      border-radius: 50%;
      border: 1px solid rgba(255,255,255,0.25);
      background: rgba(255,255,255,0.06);
      color: #fff;
      font-size: clamp(14px, 3vw, 20px);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      padding: 0;
      flex: 0 0 auto;
    }
    .tool-btn.small {
      width: clamp(26px, 6.5vw, 36px);
      height: clamp(26px, 6.5vw, 36px);
      font-size: clamp(13px, 2.8vw, 18px);
    }
    .tool-btn:disabled {
      opacity: 0.35;
      cursor: default;
    }
    .tool-group-sep {
      width: 4px;
      flex: 0 0 auto;
    }
    .rec-timer {
      font-size: 11px;
      min-width: 40px;
      text-align: center;
      color: #eee;
      flex: 0 0 auto;
    }

    /* ãƒ•ãƒ­ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãƒ‘ãƒãƒ«å…±é€š */
    .floating-panel {
      position: fixed;
      background: rgba(0,0,0,0.8);
      padding: 6px 8px;
      border-radius: 10px;
      font-size: 11px;
      color: #eee;
      z-index: 25;
      max-width: 260px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.6);
    }
    .floating-panel .panel-title {
      font-weight: 600;
      margin-bottom: 4px;
      font-size: 11px;
    }
    .floating-panel label {
      display: flex;
      align-items: center;
      gap: 4px;
      margin-bottom: 3px;
      white-space: nowrap;
    }
    .floating-panel input[type="number"] {
      width: 50px;
      font-size: 11px;
    }
    .floating-panel input[type="color"] {
      width: 32px;
      height: 18px;
      padding: 0;
      border: none;
      background: transparent;
    }
    .floating-panel input[type="range"] {
      width: 130px;
    }
    .floating-panel select {
      font-size: 11px;
      max-width: 150px;
    }

    /* ãƒšãƒ³ãƒ‘ãƒãƒ« */
    #pen-panel {
      top: 48px;
      right: 10px;
      display: none;
    }

    /* æ˜ åƒè¨­å®šãƒ‘ãƒãƒ« */
    #video-panel {
      right: 10px;
      bottom: 84px;
      display: none;
    }

    /* ãƒ˜ãƒƒãƒ€å°ãƒœã‚¿ãƒ³ */
    #log-toggle,
    #pen-toggle,
    #btn-clear {
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.25);
      background: rgba(255,255,255,0.10);
      color: #fff;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 20px;
      padding: 0;
    }

    /* ãƒ­ã‚°ãƒ‘ãƒãƒ« */
    #log-panel {
      position: fixed;
      left: 10px;
      top: 56px;
      width: 260px;
      max-height: 50vh;
      background: rgba(0,0,0,0.8);
      border-radius: 8px;
      padding: 6px;
      font-size: 11px;
      color: #eee;
      box-shadow: 0 2px 8px rgba(0,0,0,0.6);
      z-index: 30;
      display: none;
    }
    #log-panel.open {
      display: block;
    }
    #log {
      max-height: 40vh;
      overflow-y: auto;
      white-space: pre-line;
    }

    /* ã‚ºãƒ¼ãƒ é¸æŠä¸­ã®æ¡ˆå†…ãƒ†ã‚­ã‚¹ãƒˆ */
    #zoom-hint {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.7);
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 12px;
      color: #fff;
      z-index: 25;
      display: none;
      pointer-events: none;
    }
    #zoom-hint.visible {
      display: block;
    }
  </style>
</head>
<body>
  <div id="app">
    <header>
      <span class="title">ã‚«ãƒ¡ãƒ©ï¼‹æ‰‹æãï¼‹ã‚ºãƒ¼ãƒ ï¼‹æ˜ åƒèª¿æ•´ï¼‹é™æ­¢ç”»ï¼å‹•ç”»ï¼TLï¼‹ãªã’ãªã‚ï¼‹ã‚¹ãƒ†ãƒƒã‚«ãƒ¼ä¿å­˜</span>
      <div id="header-right">
        <button id="pen-toggle" title="æ‰‹æãè¨­å®šã®è¡¨ç¤º/éè¡¨ç¤º">âœï¸</button>
        <button id="btn-clear" title="æ‰‹æãã‚¯ãƒªã‚¢ï¼‹ã‚¹ãƒ†ãƒƒã‚«ãƒ¼å‰Šé™¤">ğŸ§¹</button>
        <button id="log-toggle" title="ãƒ­ã‚°è¡¨ç¤ºï¼éè¡¨ç¤º">â„¹ï¸</button>
      </div>
    </header>

    <div id="camera-wrapper">
      <div id="camera-inner">
        <video id="video" autoplay playsinline></video>
        <canvas id="draw-layer"></canvas>
        <canvas id="ui-layer"></canvas>
      </div>
    </div />

    <!-- ä¸‹ã®ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ -->
    <div id="toolbar">
      <!-- ã‚«ãƒ¡ãƒ© -->
      <button id="btn-start-camera" class="tool-btn" title="ã‚«ãƒ¡ãƒ©é–‹å§‹">ğŸ¦</button>

      <div class="tool-group-sep"></div>

      <!-- é™æ­¢ç”» -->
      <button id="btn-shot" class="tool-btn" title="å†™çœŸæ’®å½±ï¼ˆPNGï¼‰" disabled>ğŸ“·</button>

      <div class="tool-group-sep"></div>

      <!-- é€šå¸¸å‹•ç”» -->
      <button id="btn-start-rec" class="tool-btn small" title="å‹•ç”»éŒ²ç”»é–‹å§‹" disabled>âº</button>
      <button id="btn-stop-rec" class="tool-btn small" title="å‹•ç”»éŒ²ç”»åœæ­¢" disabled>â¹</button>
      <span id="rec-timer" class="rec-timer">00:00</span>

      <div class="tool-group-sep"></div>

      <!-- ã‚¿ã‚¤ãƒ ãƒ©ãƒ—ã‚¹ -->
      <button id="btn-start-tl" class="tool-btn small" title="TLéŒ²ç”»é–‹å§‹" disabled>â±</button>
      <button id="btn-stop-tl" class="tool-btn small" title="TLéŒ²ç”»åœæ­¢" disabled>â¹</button>
      <span id="tl-timer" class="rec-timer">00:00</span>

      <div class="tool-group-sep"></div>

      <!-- ã‚ºãƒ¼ãƒ  -->
      <button id="btn-zoom-select" class="tool-btn small" title="ã‚ºãƒ¼ãƒ é ˜åŸŸã‚’é¸æŠ">ğŸ”</button>
      <button id="btn-zoom-reset" class="tool-btn small" title="ã‚ºãƒ¼ãƒ è§£é™¤">ğŸ”</button>

      <div class="tool-group-sep" style="width:8px;"></div>

      <!-- æ˜ åƒè¨­å®šã‚¢ã‚¤ã‚³ãƒ³ -->
      <button id="video-settings-toggle" class="tool-btn small" title="æ˜ åƒè¨­å®šã®è¡¨ç¤º/éè¡¨ç¤º">ğŸš</button>
    </div>

    <!-- æ‰‹æãè¨­å®šãƒ‘ãƒãƒ« -->
    <div id="pen-panel" class="floating-panel">
      <div class="panel-title">æ‰‹æãè¨­å®š</div>
      <label>è‰²
        <input type="color" id="pen-color" value="#ff0000">
      </label>
      <label>å¤ªã•
        <input type="number" id="pen-size" min="1" max="40" value="5">
      </label>

      <!-- ãƒšãƒ³ç¨®é¡ -->
      <label>ãƒšãƒ³ç¨®é¡
        <select id="pen-type">
          <option value="watercolor">æ°´å½©ç”»</option>
          <option value="chalk">ãƒãƒ§ãƒ¼ã‚¯</option>
          <option value="crayon">ã‚¯ãƒ¬ãƒ¨ãƒ³</option>
          <option value="marker" selected>ãƒã‚¸ãƒƒã‚¯</option>
        </select>
      </label>

      <!-- ã‚¹ãƒã‚¤ãƒˆ -->
      <label style="margin-top:4px; flex-direction: column; align-items: flex-start;">
        <button type="button" id="pen-eyedropper"
          style="font-size:11px;padding:2px 6px;border-radius:6px;border:1px solid rgba(255,255,255,0.3);background:rgba(255,255,255,0.08);color:#fff;cursor:pointer;">
          ğŸ¯ æ˜ åƒã‹ã‚‰è‰²ã‚’å–ã‚‹
        </button>
        <span style="margin-top:2px;color:#ccc;">æŠ¼ã—ãŸã‚ã¨ã€æ˜ åƒä¸Šã‚’ã‚¿ãƒƒãƒ—ã™ã‚‹ã¨ãã®è‰²ãŒãƒšãƒ³è‰²ã«ãªã‚Šã¾ã™ã€‚</span>
      </label>

      <!-- ãªã’ãªã‚ -->
      <label style="margin-top:4px; flex-direction: column; align-items: flex-start;">
        <button type="button" id="pen-lasso"
          style="font-size:11px;padding:2px 6px;border-radius:6px;border:1px solid rgba(255,255,255,0.3);background:rgba(255,255,255,0.08);color:#fff;cursor:pointer;">
          âœ‚ï¸ ãªã’ãªã‚åˆ‡ã‚Šå‡ºã—
        </button>
        <span style="margin-top:2px;color:#ccc;">ONã«ã—ã¦æ˜ åƒã‚’ãã‚‹ã£ã¨å›²ã‚€ã¨ã€ãã®éƒ¨åˆ†ã‚’ç”»åƒã¨ã—ã¦åˆ‡ã‚Šå‡ºã—ã¾ã™ã€‚</span>
      </label>

      <!-- ã‚¹ãƒ†ãƒƒã‚«ãƒ¼ä¿å­˜ï¼èª­è¾¼ï¼å‰Šé™¤ -->
      <label style="margin-top:4px; flex-direction: column; align-items: flex-start;">
        <div style="display:flex; gap:4px; flex-wrap:wrap;">
          <button type="button" id="sticker-save"
            style="font-size:11px;padding:2px 6px;border-radius:6px;border:1px solid rgba(255,255,255,0.3);background:rgba(255,255,255,0.08);color:#fff;cursor:pointer;">
            ğŸ’¾ ã‚¹ãƒ†ãƒƒã‚«ãƒ¼ä¿å­˜
          </button>
          <button type="button" id="sticker-load"
            style="font-size:11px;padding:2px 6px;border-radius:6px;border:1px solid rgba(255,255,255,0.3);background:rgba(255,255,255,0.08);color:#fff;cursor:pointer;">
            ğŸ“‚ èª­è¾¼
          </button>
          <button type="button" id="sticker-delete"
            style="font-size:11px;padding:2px 6px;border-radius:6px;border:1px solid rgba(255,80,80,0.8);background:rgba(255,80,80,0.15);color:#fff;cursor:pointer;">
            ğŸ—‘ å‰Šé™¤
          </button>
        </div>
        <span style="margin-top:2px;color:#ccc;">ã‚¹ãƒ†ãƒƒã‚«ãƒ¼é…ç½®ã®ä¿å­˜ï¼èª­è¾¼ï¼é¸æŠä¸­ã‚¹ãƒ†ãƒƒã‚«ãƒ¼ã®å‰Šé™¤ã€‚</span>
      </label>
      <input type="file" id="sticker-file" accept="application/json" style="display:none;">
    </div>

    <!-- æ˜ åƒï¼‹éŒ²ç”»è¨­å®šãƒ‘ãƒãƒ« -->
    <div id="video-panel" class="floating-panel">
      <div class="panel-title">éŒ²ç”»ï¼ã‚¿ã‚¤ãƒ ãƒ©ãƒ—ã‚¹è¨­å®š</div>
      <label>å‹•ç”»FPS
        <input type="number" id="video-fps" min="1" max="60" value="30">
      </label>
      <label>TL-FPS
        <input type="number" id="tl-fps" min="1" max="60" value="10">
      </label>
      <label>TLé–“éš”(ms)
        <input type="number" id="tl-interval" min="100" value="500">
      </label>

      <div class="panel-title" style="margin-top:4px;">æ˜ åƒè¨­å®š</div>
      <label>æ˜ã‚‹ã•
        <input id="brightness" type="range" min="0.2" max="2" step="0.01" value="1">
      </label>
      <label>ã‚³ãƒ³ãƒˆãƒ©ã‚¹ãƒˆ
        <input id="contrast" type="range" min="0.5" max="2" step="0.01" value="1">
      </label>
      <label>éœ²å‡º
        <input id="exposure" type="range" min="-2" max="2" step="0.1" value="0">
      </label>
      <label>è‰²æ¸©åº¦
        <input id="color-temp" type="range" min="-1" max="1" step="0.1" value="0">
      </label>
      <label>ã‚·ãƒ£ãƒ¼ãƒ—
        <input id="sharpness" type="range" min="0" max="1" step="0.1" value="0">
      </label>
      <label>
        <input id="line-boost" type="checkbox">
        ç·šãƒ»æ–‡å­—ãã£ãã‚Š
      </label>
      <label>
        <input id="noise-reduce" type="checkbox">
        ãƒã‚¤ã‚ºè»½æ¸›ï¼ˆã‚ºãƒ¼ãƒ æ™‚ã®ã‚‚ã‚„ã‚‚ã‚„æŠ‘åˆ¶ï¼‰
      </label>

      <div class="panel-title" style="margin-top:4px;">è¡¨ç¤ºåè»¢</div>
      <label>
        <input id="flip-h" type="checkbox" checked>
        å·¦å³åè»¢ï¼ˆãƒŸãƒ©ãƒ¼ï¼‰
      </label>
      <label>
        <input id="flip-v" type="checkbox">
        ä¸Šä¸‹åè»¢
      </label>

      <div class="panel-title" style="margin-top:4px;">ã‚«ãƒ¡ãƒ©é¸æŠ</div>
      <label>ã‚«ãƒ¡ãƒ©
        <select id="camera-select" disabled></select>
      </label>

      <div class="panel-title" style="margin-top:4px;">éŸ³å£°</div>
      <label>
        <input id="audio-enabled" type="checkbox">
        å‹•ç”»ã«ãƒã‚¤ã‚¯éŸ³å£°ã‚’å…¥ã‚Œã‚‹
      </label>
      <div style="margin-top:3px;color:#ccc;">
        â€»ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯éŸ³å£°OFFã§ã™ã€‚<br>
        â€»ã€Œç·šãƒ»æ–‡å­—ãã£ãã‚Šã€ã€Œãƒã‚¤ã‚ºè»½æ¸›ã€ã¯ä¸»ã«ä¿å­˜ç”»åƒï¼éŒ²ç”»å‹•ç”»ã«åæ˜ ã•ã‚Œã¾ã™ã€‚<br>
        â€»ãƒ–ãƒ©ã‚¦ã‚¶éŒ²ç”»ã¯ WebM å½¢å¼ã§ä¿å­˜ã•ã‚Œã¾ã™ã€‚mp4/mov ãŒå¿…è¦ãªå ´åˆã¯å¤–éƒ¨ãƒ„ãƒ¼ãƒ«ã§å¤‰æ›ã—ã¦ãã ã•ã„ã€‚
      </div>
    </div>

    <!-- ãƒ­ã‚°ãƒ‘ãƒãƒ« -->
    <div id="log-panel">
      <div style="font-weight:600;margin-bottom:4px;">ãƒ­ã‚°</div>
      <div id="log"></div>
      <div style="margin-top:4px;color:#ccc;">
        â€»ã‚ºãƒ¼ãƒ æ™‚ã¯ã€éŒ²ç”»ãƒ»TLã‚‚ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã¨åŒã˜è¦‹ãˆæ–¹ã§ä¿å­˜ã—ã¾ã™ã€‚<br>
        â€»ã€Œç·šãƒ»æ–‡å­—ãã£ãã‚Šã€ã¯ãƒãƒ¼ãƒˆã‚„ãƒ—ãƒªãƒ³ãƒˆæ’®å½±å‘ãã§ã™ã€‚
      </div>
    </div>

    <!-- ã‚ºãƒ¼ãƒ é¸æŠä¸­ã®ãƒ’ãƒ³ãƒˆ -->
    <div id="zoom-hint">ã‚ºãƒ¼ãƒ ã—ãŸã„ç¯„å›²ã‚’ãƒ‰ãƒ©ãƒƒã‚°ï¼ˆæŒ‡ï¼ãƒšãƒ³ï¼ãƒã‚¦ã‚¹ï¼‰</div>
  </div>

  <script>
    /* ===== è¦ç´ ï¼çŠ¶æ…‹ ===== */
    const video = document.getElementById('video');
    const drawCanvas = document.getElementById('draw-layer');
    const drawCtx = drawCanvas.getContext('2d');
    const uiCanvas = document.getElementById('ui-layer');
    const uiCtx = uiCanvas.getContext('2d');
    const cameraWrapper = document.getElementById('camera-wrapper');
    const cameraInner = document.getElementById('camera-inner');

    const btnStartCamera = document.getElementById('btn-start-camera');
    const btnClear = document.getElementById('btn-clear');
    const btnShot = document.getElementById('btn-shot');
    const btnStartRec = document.getElementById('btn-start-rec');
    const btnStopRec = document.getElementById('btn-stop-rec');
    const btnStartTl = document.getElementById('btn-start-tl');
    const btnStopTl = document.getElementById('btn-stop-tl');
    const btnZoomSelect = document.getElementById('btn-zoom-select');
    const btnZoomReset = document.getElementById('btn-zoom-reset');
    const videoSettingsToggle = document.getElementById('video-settings-toggle');

    const penToggle = document.getElementById('pen-toggle');
    const penPanel = document.getElementById('pen-panel');
    const videoPanel = document.getElementById('video-panel');

    const penColorInput = document.getElementById('pen-color');
    const penSizeInput = document.getElementById('pen-size');
    const penTypeSelect = document.getElementById('pen-type');
    let penType = 'marker';

    const videoFpsInput = document.getElementById('video-fps');
    const tlFpsInput = document.getElementById('tl-fps');
    const tlIntervalInput = document.getElementById('tl-interval');

    const brightnessSlider = document.getElementById('brightness');
    const contrastSlider = document.getElementById('contrast');
    const exposureSlider = document.getElementById('exposure');
    const colorTempSlider = document.getElementById('color-temp');
    const sharpnessSlider = document.getElementById('sharpness');
    const lineBoostCheckbox = document.getElementById('line-boost');
    const noiseReduceCheckbox = document.getElementById('noise-reduce');
    const flipHCheckbox = document.getElementById('flip-h');
    const flipVCheckbox = document.getElementById('flip-v');
    const audioEnabledCheckbox = document.getElementById('audio-enabled');
    const cameraSelect = document.getElementById('camera-select');

    const logEl = document.getElementById('log');
    const logPanel = document.getElementById('log-panel');
    const logToggle = document.getElementById('log-toggle');
    const zoomHint = document.getElementById('zoom-hint');

    const recTimerEl = document.getElementById('rec-timer');
    const tlTimerEl = document.getElementById('tl-timer');

    const eyedropperBtn = document.getElementById('pen-eyedropper');
    const lassoBtn = document.getElementById('pen-lasso');
    const stickerSaveBtn = document.getElementById('sticker-save');
    const stickerLoadBtn = document.getElementById('sticker-load');
    const stickerDeleteBtn = document.getElementById('sticker-delete');
    const stickerFileInput = document.getElementById('sticker-file');

    let eyedropperMode = false;
    let lassoMode = false;
    let isLassoDrawing = false;
    let lassoPath = []; // {x,y} (uiCanvasåº§æ¨™)

    // ã‚¹ãƒ†ãƒƒã‚«ãƒ¼ç®¡ç†
    let stickers = [];           // {canvas,w,h,x,y,scale,rotation}
    let activeStickerIndex = -1;
    let showStickerControls = true;

    const compositeCanvas = document.createElement('canvas');
    const compositeCtx = compositeCanvas.getContext('2d');

    let cameraStream = null;
    let currentVideoDeviceId = null;
    let hasInitializedCamera = false;

    const supportsMediaRecorder = typeof MediaRecorder !== 'undefined';
    let supportsCaptureStream = false;
    try {
      supportsCaptureStream = typeof compositeCanvas.captureStream === 'function';
    } catch (e) {
      supportsCaptureStream = false;
    }

    drawCtx.imageSmoothingEnabled = false;
    uiCtx.imageSmoothingEnabled = false;
    compositeCtx.imageSmoothingEnabled = false;

    // æ‰‹æãçŠ¶æ…‹
    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;

    // éŒ²ç”»
    let recorder = null;
    let recordedChunks = [];
    let recordingMode = null;
    let animationId = null;
    let lastTlTime = 0;
    let tlIntervalMs = 500;
    let recStartTime = null;
    let tlStartTime = null;
    let recTimerId = null;
    let tlTimerId = null;

    // ã‚ºãƒ¼ãƒ 
    let zoomMode = false;
    let zoomRect = null;
    let zoomDragStart = null;
    let lastZoomPos = null;

    // æ˜ åƒè¨­å®š
    const settings = {
      brightness: 1,
      contrast: 1,
      exposure: 0,
      colorTemp: 0,
      sharpness: 0,
      lineBoost: false,
      noiseReduce: false
    };
    let videoFilterString = 'brightness(1) contrast(1)';
    let flipH = true;
    let flipV = false;
    let audioEnabled = false;
    audioEnabledCheckbox.checked = false;

    // ã‚¹ãƒ†ãƒƒã‚«ãƒ¼ãƒ‰ãƒ©ãƒƒã‚°
    const stickerDrag = {
      active: false,
      mode: null, // "move" or "rotate"
      startX: 0,
      startY: 0,
      startScale: 1,
      startRotation: 0,
      startPointerX: 0,
      startPointerY: 0,
      startDist: 0,
      startAngle: 0
    };

    function log(msg) {
      const now = new Date();
      const time = now.toLocaleTimeString();
      logEl.textContent = `[${time}] ${msg}\n` + logEl.textContent;
    }

    if (!supportsMediaRecorder || !supportsCaptureStream) {
      log('ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã§ã¯éŒ²ç”»ï¼ã‚¿ã‚¤ãƒ ãƒ©ãƒ—ã‚¹æ©Ÿèƒ½ãŒå®Œå…¨ã«ã¯ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ï¼ˆé™æ­¢ç”»ã¯åˆ©ç”¨å¯èƒ½ï¼‰ã€‚');
    }

    function formatTime(ms) {
      const totalSec = Math.floor(ms / 1000);
      const m = Math.floor(totalSec / 60);
      const s = totalSec % 60;
      return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
    }

    function startRecTimer() {
      recStartTime = Date.now();
      recTimerEl.textContent = '00:00';
      if (recTimerId) clearInterval(recTimerId);
      recTimerId = setInterval(() => {
        recTimerEl.textContent = formatTime(Date.now() - recStartTime);
      }, 500);
    }
    function stopRecTimer() {
      if (recTimerId) {
        clearInterval(recTimerId);
        recTimerId = null;
      }
    }
    function startTlTimer() {
      tlStartTime = Date.now();
      tlTimerEl.textContent = '00:00';
      if (tlTimerId) clearInterval(tlTimerId);
      tlTimerId = setInterval(() => {
        tlTimerEl.textContent = formatTime(Date.now() - tlStartTime);
      }, 500);
    }
    function stopTlTimer() {
      if (tlTimerId) {
        clearInterval(tlTimerId);
        tlTimerId = null;
      }
    }

    logToggle.addEventListener('click', () => {
      logPanel.classList.toggle('open');
    });
    penToggle.addEventListener('click', () => {
      penPanel.style.display = penPanel.style.display === 'block' ? 'none' : 'block';
    });
    videoSettingsToggle.addEventListener('click', () => {
      videoPanel.style.display = videoPanel.style.display === 'block' ? 'none' : 'block';
    });

    audioEnabledCheckbox.addEventListener('change', () => {
      audioEnabled = audioEnabledCheckbox.checked;
      log(`éŸ³å£°éŒ²éŸ³: ${audioEnabled ? 'ON' : 'OFF'}`);
      if (cameraStream) {
        cameraStream.getAudioTracks().forEach(t => {
          t.enabled = audioEnabled;
        });
      }
    });

    penTypeSelect.addEventListener('change', () => {
      penType = penTypeSelect.value;
      log(`ãƒšãƒ³ç¨®é¡: ${penTypeSelect.options[penTypeSelect.selectedIndex].text}`);
    });

    /* ===== ã‚«ãƒ¡ãƒ© ===== */
    async function populateCameraList() {
      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const videoDevices = devices.filter(d => d.kind === 'videoinput');
        cameraSelect.innerHTML = '';

        videoDevices.forEach((d, idx) => {
          const opt = document.createElement('option');
          opt.value = d.deviceId;
          opt.textContent = d.label || `ã‚«ãƒ¡ãƒ© ${idx + 1}`;
          cameraSelect.appendChild(opt);
        });

        if (!currentVideoDeviceId && videoDevices[0]) {
          currentVideoDeviceId = videoDevices[0].deviceId;
        }
        if (currentVideoDeviceId) {
          cameraSelect.value = currentVideoDeviceId;
        }

        cameraSelect.disabled = videoDevices.length <= 1;
        if (videoDevices.length > 1) {
          log(`ã‚«ãƒ¡ãƒ©ã‚’ ${videoDevices.length} å°æ¤œå‡ºã—ã¾ã—ãŸã€‚æ˜ åƒè¨­å®šã‹ã‚‰åˆ‡ã‚Šæ›¿ãˆã§ãã¾ã™ã€‚`);
        }
      } catch (e) {
        console.log('enumerateDevices error', e);
      }
    }

    async function initCamera(deviceId = null) {
      try {
        if (cameraStream) {
          cameraStream.getTracks().forEach(t => t.stop());
        }

        const constraints = {
          video: deviceId
            ? { deviceId: { exact: deviceId }, width: { ideal: 1920 }, height: { ideal: 1080 } }
            : { width: { ideal: 1920 }, height: { ideal: 1080 } },
          audio: true
        };

        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        cameraStream = stream;
        hasInitializedCamera = true;

        cameraStream.getAudioTracks().forEach(t => { t.enabled = audioEnabled; });

        video.srcObject = cameraStream;
        log(deviceId ? 'ã‚«ãƒ¡ãƒ©ã‚’åˆ‡ã‚Šæ›¿ãˆã¾ã—ãŸ' : 'ã‚«ãƒ¡ãƒ©ã‚’é–‹å§‹ã—ã¾ã—ãŸ');

        video.addEventListener('loadedmetadata', () => {
          resizeCanvases();
          btnShot.disabled = false;
          if (supportsMediaRecorder && supportsCaptureStream) {
            btnStartRec.disabled = false;
            btnStartTl.disabled = false;
          } else {
            btnStartRec.disabled = true;
            btnStopRec.disabled = true;
            btnStartTl.disabled = true;
            btnStopTl.disabled = true;
          }
        }, { once: true });

        btnStartCamera.disabled = true;

        await populateCameraList();
      } catch (e) {
        console.error(e);
        log('ã‚«ãƒ¡ãƒ©ãŒè¨±å¯ã•ã‚Œãªã‹ã£ãŸã‹ã€é¸æŠã—ãŸã‚«ãƒ¡ãƒ©ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“ã§ã—ãŸ');
      }
    }

    btnStartCamera.addEventListener('click', () => {
      initCamera(currentVideoDeviceId);
    });

    cameraSelect.addEventListener('change', () => {
      const devId = cameraSelect.value;
      currentVideoDeviceId = devId;
      if (hasInitializedCamera) {
        initCamera(devId);
      }
    });

    /* ===== ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚º ===== */
    function resizeCanvases() {
      const rect = cameraWrapper.getBoundingClientRect();
      const width = rect.width;
      const height = rect.height;
      const dpr = window.devicePixelRatio || 1;

      [drawCanvas, uiCanvas, compositeCanvas].forEach(c => {
        c.width = width * dpr;
        c.height = height * dpr;
        if (c !== compositeCanvas) {
          c.style.width = width + 'px';
          c.style.height = height + 'px';
        }
      });

      drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
      uiCtx.clearRect(0, 0, uiCanvas.width, uiCanvas.height);

      zoomRect = null;
      updateZoomTransform();

      stickers = [];
      activeStickerIndex = -1;
      lassoPath = [];
      isLassoDrawing = false;
      showStickerControls = false;
      uiCanvas.style.pointerEvents = 'none';

      log(`ã‚­ãƒ£ãƒ³ãƒã‚¹: ${width}x${height} (DPR=${dpr} â†’ å†…éƒ¨ ${drawCanvas.width}x${drawCanvas.height})`);
    }

    window.addEventListener('resize', () => {
      if (video.videoWidth) resizeCanvases();
    });

    window.addEventListener('orientationchange', () => {
      setTimeout(() => {
        window.scrollTo(0, 0);
        if (video.videoWidth) resizeCanvases();
      }, 200);
    });

    /* ===== åº§æ¨™å¤‰æ› ===== */
    function getCanvasPos(e) {
      const rect = drawCanvas.getBoundingClientRect();
      let clientX, clientY;
      if (e.touches && e.touches[0]) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
      } else {
        clientX = e.clientX;
        clientY = e.clientY;
      }
      const x = (clientX - rect.left) * (drawCanvas.width / rect.width);
      const y = (clientY - rect.top) * (drawCanvas.height / rect.height);
      return { x, y, clientX, clientY };
    }

    function getUiCanvasPos(e) {
      const rect = uiCanvas.getBoundingClientRect();
      let clientX, clientY;
      if (e.touches && e.touches[0]) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
      } else {
        clientX = e.clientX;
        clientY = e.clientY;
      }
      const x = (clientX - rect.left) * (uiCanvas.width / rect.width);
      const y = (clientY - rect.top) * (uiCanvas.height / rect.height);
      return { x, y };
    }

    function getWrapperPosFromClient(clientX, clientY) {
      const rect = cameraWrapper.getBoundingClientRect();
      return {
        x: clientX - rect.left,
        y: clientY - rect.top
      };
    }

    /* ===== ã‚¹ãƒã‚¤ãƒˆ ===== */
    function pickColorAtCssPos(cssX, cssY) {
      if (!video.videoWidth || !compositeCanvas.width || !compositeCanvas.height) {
        log('ã‚«ãƒ¡ãƒ©èµ·å‹•å¾Œã«è‰²ã‚’å–å¾—ã§ãã¾ã™');
        return;
      }
      drawCompositeFrame();

      const rect = cameraWrapper.getBoundingClientRect();
      const px = Math.floor(cssX * (compositeCanvas.width / rect.width));
      const py = Math.floor(cssY * (compositeCanvas.height / rect.height));
      if (px < 0 || py < 0 || px >= compositeCanvas.width || py >= compositeCanvas.height) return;

      const data = compositeCtx.getImageData(px, py, 1, 1).data;
      const r = data[0], g = data[1], b = data[2];
      const toHex = v => v.toString(16).padStart(2, '0');
      const hex = `#${toHex(r)}${toHex(g)}${toHex(b)}`;
      penColorInput.value = hex;
      log(`ã‚¹ãƒã‚¤ãƒˆã§è‰²ã‚’å–å¾—: ${hex} (R${r} G${g} B${b})`);
    }

    eyedropperBtn.addEventListener('click', () => {
      eyedropperMode = !eyedropperMode;
      if (eyedropperMode) {
        lassoMode = false;
        isLassoDrawing = false;
        lassoPath = [];
        lassoBtn.style.borderColor = 'rgba(255,255,255,0.3)';
        uiCanvas.style.pointerEvents = stickers.length ? 'auto' : 'none';
      }
      eyedropperBtn.style.borderColor = eyedropperMode
        ? 'rgba(0,255,180,0.9)'
        : 'rgba(255,255,255,0.3)';
      log(`ã‚¹ãƒã‚¤ãƒˆ: ${eyedropperMode ? 'ONï¼ˆæ˜ åƒä¸Šã‚’ã‚¿ãƒƒãƒ—ã—ã¦ãã ã•ã„ï¼‰' : 'OFF'}`);
    });

    /* ===== ãƒšãƒ³æç”»ï¼ˆãƒ–ãƒ©ã‚·è¡¨ç¾ï¼‰ ===== */
    function drawStrokeSegment(x0, y0, x1, y1) {
      const color = penColorInput.value;
      const baseSize = Number(penSizeInput.value) || 3;

      if (penType === 'watercolor') {
        // æ°´å½©ï¼šã‚„ã‚ã‚‰ã‹ãé€ã‘ã‚‹ç·šã‚’é‡ã­å¡—ã‚Š
        drawCtx.save();
        drawCtx.strokeStyle = color;
        drawCtx.lineCap = 'round';
        drawCtx.lineJoin = 'round';

        drawCtx.globalAlpha = 0.18;
        drawCtx.lineWidth = baseSize * 2.2;
        drawCtx.beginPath();
        drawCtx.moveTo(x0, y0);
        drawCtx.lineTo(x1, y1);
        drawCtx.stroke();

        drawCtx.globalAlpha = 0.08;
        drawCtx.lineWidth = baseSize * 3.0;
        drawCtx.beginPath();
        drawCtx.moveTo(x0, y0);
        drawCtx.lineTo(x1, y1);
        drawCtx.stroke();

        drawCtx.restore();
        return;
      }

      if (penType === 'chalk') {
        // ãƒãƒ§ãƒ¼ã‚¯ï¼šå°‘ã—ã‚¶ãƒ©ãƒƒã¨ã—ãŸãƒ©ã‚¤ãƒ³ï¼‹ç²‰ã£ã½ã„ç²’
        drawCtx.save();
        drawCtx.strokeStyle = color;
        drawCtx.lineCap = 'round';
        drawCtx.lineJoin = 'round';

        drawCtx.globalAlpha = 0.4;
        drawCtx.lineWidth = baseSize * 1.4;
        drawCtx.beginPath();
        drawCtx.moveTo(x0, y0);
        drawCtx.lineTo(x1, y1);
        drawCtx.stroke();

        // ç²‰ã£ã½ã„ç²’
        const len = Math.hypot(x1 - x0, y1 - y0);
        const steps = Math.max(4, Math.floor(len / 10));
        drawCtx.globalAlpha = 0.6;
        drawCtx.fillStyle = color;
        for (let i = 0; i < steps; i++) {
          const t = i / steps;
          const px = x0 + (x1 - x0) * t;
          const py = y0 + (y1 - y0) * t;
          const ox = (Math.random() - 0.5) * baseSize;
          const oy = (Math.random() - 0.5) * baseSize;
          drawCtx.fillRect(px + ox, py + oy, 1.2, 1.2);
        }

        drawCtx.restore();
        return;
      }

      if (penType === 'crayon') {
        // ã‚¯ãƒ¬ãƒ¨ãƒ³ï¼šå°‘ã—æºã‚‰ã„ã ç·šã‚’ä½•æœ¬ã‹é‡ã­ã‚‹
        drawCtx.save();
        drawCtx.strokeStyle = color;
        drawCtx.lineCap = 'round';
        drawCtx.lineJoin = 'round';

        const jitter = baseSize * 0.6;
        const lines = 3;
        for (let i = 0; i < lines; i++) {
          const jx0 = x0 + (Math.random() - 0.5) * jitter;
          const jy0 = y0 + (Math.random() - 0.5) * jitter;
          const jx1 = x1 + (Math.random() - 0.5) * jitter;
          const jy1 = y1 + (Math.random() - 0.5) * jitter;
          drawCtx.globalAlpha = 0.55;
          drawCtx.lineWidth = baseSize * 0.95;
          drawCtx.beginPath();
          drawCtx.moveTo(jx0, jy0);
          drawCtx.lineTo(jx1, jy1);
          drawCtx.stroke();
        }

        drawCtx.restore();
        return;
      }

      // ãƒã‚¸ãƒƒã‚¯ï¼šã—ã£ã‹ã‚Šã—ãŸä¸é€æ˜ãƒ©ã‚¤ãƒ³
      drawCtx.save();
      drawCtx.strokeStyle = color;
      drawCtx.lineCap = 'round';
      drawCtx.lineJoin = 'round';
      drawCtx.globalAlpha = 0.95;
      drawCtx.lineWidth = baseSize * 1.3;
      drawCtx.beginPath();
      drawCtx.moveTo(x0, y0);
      drawCtx.lineTo(x1, y1);
      drawCtx.stroke();
      drawCtx.restore();
    }

    function startDraw(e) {
      if (zoomMode) return;
      if (lassoMode) return;
      e.preventDefault();

      const pos = getCanvasPos(e);

      if (eyedropperMode) {
        const rect = cameraWrapper.getBoundingClientRect();
        const cssX = pos.clientX - rect.left;
        const cssY = pos.clientY - rect.top;
        pickColorAtCssPos(cssX, cssY);
        eyedropperMode = false;
        eyedropperBtn.style.borderColor = 'rgba(255,255,255,0.3)';
        return;
      }

      // æ‰‹æãé–‹å§‹æ™‚ã¯ã‚¹ãƒ†ãƒƒã‚«ãƒ¼ã®æ ï¼ãƒãƒ³ãƒ‰ãƒ«ã‚’éš ã™
      showStickerControls = false;
      if (stickers.length) {
        uiCtx.clearRect(0, 0, uiCanvas.width, uiCanvas.height);
        redrawStickerOverlay(false);
      }

      isDrawing = true;
      lastX = pos.x;
      lastY = pos.y;
    }

    function draw(e) {
      if (!isDrawing || zoomMode) return;
      if (lassoMode) return;
      e.preventDefault();
      const pos = getCanvasPos(e);
      drawStrokeSegment(lastX, lastY, pos.x, pos.y);
      lastX = pos.x;
      lastY = pos.y;
    }

    function endDraw(e) {
      if (!isDrawing) return;
      e.preventDefault();
      isDrawing = false;
    }

    drawCanvas.addEventListener('mousedown', startDraw);
    drawCanvas.addEventListener('mousemove', draw);
    drawCanvas.addEventListener('mouseup', endDraw);
    drawCanvas.addEventListener('mouseleave', endDraw);

    drawCanvas.addEventListener('touchstart', startDraw, { passive: false });
    drawCanvas.addEventListener('touchmove', draw, { passive: false });
    drawCanvas.addEventListener('touchend', endDraw, { passive: false });
    drawCanvas.addEventListener('touchcancel', endDraw, { passive: false });

    btnClear.addEventListener('click', () => {
      drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
      uiCtx.clearRect(0, 0, uiCanvas.width, uiCanvas.height);
      stickers = [];
      activeStickerIndex = -1;
      lassoPath = [];
      isLassoDrawing = false;
      showStickerControls = false;
      uiCanvas.style.pointerEvents = 'none';
      log('æ‰‹æããƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã‚¹ãƒ†ãƒƒã‚«ãƒ¼ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ');
    });

    /* ===== æ˜ åƒãƒ•ã‚£ãƒ«ã‚¿ ===== */
    function updateVideoFilter() {
      const exposureFactor = Math.pow(2, settings.exposure);
      const b = settings.brightness * exposureFactor;
      const c = settings.contrast;
      const t = settings.colorTemp;

      let filter = `brightness(${b}) contrast(${c})`;
      if (t > 0) {
        const amt = t;
        filter += ` sepia(${amt}) saturate(${1 + 0.5 * amt}) hue-rotate(-10deg)`;
      } else if (t < 0) {
        const amt = -t;
        filter += ` saturate(${1 - 0.3 * amt}) hue-rotate(${amt * 20}deg)`;
      }
      videoFilterString = filter;
      video.style.filter = filter;
    }

    function updateVideoFlipPreview() {
      const sx = flipH ? -1 : 1;
      const sy = flipV ? -1 : 1;
      video.style.transform = `scaleX(${sx}) scaleY(${sy})`;
    }

    brightnessSlider.addEventListener('input', () => {
      settings.brightness = parseFloat(brightnessSlider.value) || 1;
      updateVideoFilter();
    });
    contrastSlider.addEventListener('input', () => {
      settings.contrast = parseFloat(contrastSlider.value) || 1;
      updateVideoFilter();
    });
    exposureSlider.addEventListener('input', () => {
      settings.exposure = parseFloat(exposureSlider.value) || 0;
      updateVideoFilter();
    });
    colorTempSlider.addEventListener('input', () => {
      settings.colorTemp = parseFloat(colorTempSlider.value) || 0;
      updateVideoFilter();
    });
    sharpnessSlider.addEventListener('input', () => {
      settings.sharpness = parseFloat(sharpnessSlider.value) || 0;
    });
    lineBoostCheckbox.addEventListener('change', () => {
      settings.lineBoost = lineBoostCheckbox.checked;
      log(`ç·šãƒ»æ–‡å­—ãã£ãã‚Š: ${settings.lineBoost ? 'ON' : 'OFF'}`);
    });
    noiseReduceCheckbox.addEventListener('change', () => {
      settings.noiseReduce = noiseReduceCheckbox.checked;
      log(`ãƒã‚¤ã‚ºè»½æ¸›: ${settings.noiseReduce ? 'ON' : 'OFF'}`);
    });
    flipHCheckbox.addEventListener('change', () => {
      flipH = flipHCheckbox.checked;
      updateVideoFlipPreview();
      log(`å·¦å³åè»¢: ${flipH ? 'ON' : 'OFF'}`);
    });
    flipVCheckbox.addEventListener('change', () => {
      flipV = flipVCheckbox.checked;
      updateVideoFlipPreview();
      log(`ä¸Šä¸‹åè»¢: ${flipV ? 'ON' : 'OFF'}`);
    });

    updateVideoFilter();
    updateVideoFlipPreview();

    /* ===== ãƒã‚¤ã‚ºãƒ»ã‚·ãƒ£ãƒ¼ãƒ— ===== */
    function applyDenoiseToImage(img, strength) {
      if (strength <= 0) return;
      const w = img.width;
      const h = img.height;
      const data = img.data;
      const src = new Uint8ClampedArray(data);
      const k = strength;
      for (let y = 1; y < h - 1; y++) {
        for (let x = 1; x < w - 1; x++) {
          const idx = (y * w + x) * 4;
          let r = 0, g = 0, b = 0;
          for (let ky = -1; ky <= 1; ky++) {
            for (let kx = -1; kx <= 1; kx++) {
              const idx2 = ((y + ky) * w + (x + kx)) * 4;
              r += src[idx2];
              g += src[idx2 + 1];
              b += src[idx2 + 2];
            }
          }
          const blurR = r / 9;
          const blurG = g / 9;
          const blurB = b / 9;
          const origR = src[idx];
          const origG = src[idx + 1];
          const origB = src[idx + 2];

          data[idx]     = Math.max(0, Math.min(255, origR * (1-k) + blurR * k));
          data[idx + 1] = Math.max(0, Math.min(255, origG * (1-k) + blurG * k));
          data[idx + 2] = Math.max(0, Math.min(255, origB * (1-k) + blurB * k));
        }
      }
    }

    function applySharpenToImage(img, amount, lineBoost) {
      if (amount <= 0) return;
      const w = img.width;
      const h = img.height;
      const data = img.data;
      const src = new Uint8ClampedArray(data);

      const centerBase = lineBoost ? 10 : 5;
      const gain = lineBoost ? 10 : 4;
      const center = centerBase + gain * amount;

      const kernel = [
        0, -1, 0,
        -1, center, -1,
        0, -1, 0
      ];

      for (let y = 1; y < h - 1; y++) {
        for (let x = 1; x < w - 1; x++) {
          const idx = (y * w + x) * 4;
          let r = 0, g = 0, b = 0;
          let ki = 0;
          for (let ky = -1; ky <= 1; ky++) {
            for (let kx = -1; kx <= 1; kx++) {
              const idx2 = ((y + ky) * w + (x + kx)) * 4;
              const wgt = kernel[ki++];
              r += src[idx2] * wgt;
              g += src[idx2 + 1] * wgt;
              b += src[idx2 + 2] * wgt;
            }
          }
          data[idx]     = Math.max(0, Math.min(255, r));
          data[idx + 1] = Math.max(0, Math.min(255, g));
          data[idx + 2] = Math.max(0, Math.min(255, b));
        }
      }

      if (lineBoost) {
        const contrast = 1.4 + 0.6 * amount;
        for (let i = 0; i < data.length; i += 4) {
          let r = data[i], g = data[i+1], b = data[i+2];
          const yLum = 0.299*r + 0.587*g + 0.114*b;
          const y2 = 128 + (yLum - 128) * contrast;
          const ratio = yLum > 0 ? (y2 / yLum) : 1;
          data[i]   = Math.max(0, Math.min(255, r * ratio));
          data[i+1] = Math.max(0, Math.min(255, g * ratio));
          data[i+2] = Math.max(0, Math.min(255, b * ratio));
        }
      }
    }

    /* ===== ã‚¹ãƒ†ãƒƒã‚«ãƒ¼æç”» ===== */
    function drawSingleSticker(ctx, st) {
      ctx.save();
      ctx.translate(st.x, st.y);
      ctx.rotate(st.rotation);
      ctx.scale(st.scale, st.scale);
      ctx.drawImage(st.canvas, -st.w / 2, -st.h / 2);
      ctx.restore();
    }

    function drawStickersToCtx(ctx) {
      for (const st of stickers) {
        drawSingleSticker(ctx, st);
      }
    }

    function redrawStickerOverlay(clearFirst) {
      if (clearFirst) {
        uiCtx.clearRect(0, 0, uiCanvas.width, uiCanvas.height);
      }
      if (!stickers.length) return;

      stickers.forEach((st, idx) => {
        uiCtx.save();
        uiCtx.translate(st.x, st.y);
        uiCtx.rotate(st.rotation);
        uiCtx.scale(st.scale, st.scale);

        // æœ¬ä½“ç”»åƒ
        uiCtx.drawImage(st.canvas, -st.w / 2, -st.h / 2);

        // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚¹ãƒ†ãƒƒã‚«ãƒ¼ã®æ ï¼‹ãƒãƒ³ãƒ‰ãƒ«ï¼ˆè¡¨ç¤ºãƒ•ãƒ©ã‚°ãŒONã®ã¨ãã®ã¿ï¼‰
        if (idx === activeStickerIndex && showStickerControls) {
          uiCtx.strokeStyle = 'rgba(0,255,255,0.9)';
          uiCtx.lineWidth = 2;
          uiCtx.strokeRect(-st.w / 2, -st.h / 2, st.w, st.h);

          const hx = st.w / 2 + 16;
          const hy = -st.h / 2 - 16;
          const r = 10;
          uiCtx.fillStyle = 'rgba(0,255,180,0.9)';
          uiCtx.beginPath();
          uiCtx.arc(hx, hy, r, 0, Math.PI * 2);
          uiCtx.fill();
          uiCtx.strokeStyle = '#003333';
          uiCtx.lineWidth = 1;
          uiCtx.stroke();
        }

        uiCtx.restore();
      });
    }

    function getStickerLocalCoords(st, px, py) {
      const dx = px - st.x;
      const dy = py - st.y;
      const cosA = Math.cos(-st.rotation);
      const sinA = Math.sin(-st.rotation);
      const rx = dx * cosA - dy * sinA;
      const ry = dx * sinA + dy * cosA;
      return {
        x: rx / st.scale,
        y: ry / st.scale
      };
    }

    function postProcessFrame() {
      const w = compositeCanvas.width;
      const h = compositeCanvas.height;
      if (!w || !h) return;

      const needDenoise = settings.noiseReduce;
      const sharpFromSlider = settings.sharpness;
      const extraFromLine = settings.lineBoost ? 0.8 : 0;
      const sharpAmount = Math.min(1.5, Math.max(0, sharpFromSlider + extraFromLine));

      if (!needDenoise && sharpAmount <= 0) return;

      const img = compositeCtx.getImageData(0, 0, w, h);

      if (needDenoise) {
        applyDenoiseToImage(img, 0.7);
      }
      if (sharpAmount > 0) {
        applySharpenToImage(img, sharpAmount, settings.lineBoost);
      }

      compositeCtx.putImageData(img, 0, 0);
    }

    /* ===== åˆæˆãƒ•ãƒ¬ãƒ¼ãƒ ï¼ˆæ˜ åƒï¼‹æ‰‹æãï¼‹ã‚¹ãƒ†ãƒƒã‚«ãƒ¼ï¼‰ ===== */
    function drawCompositeFrame() {
      const w = compositeCanvas.width;
      const h = compositeCanvas.height;
      if (!w || !h) return;
      if (!video.videoWidth || !video.videoHeight) return;

      const Wcss = cameraWrapper.clientWidth;
      const Hcss = cameraWrapper.clientHeight;
      if (!Wcss || !Hcss) return;

      const dpr = window.devicePixelRatio || 1;
      const vw = video.videoWidth;
      const vh = video.videoHeight;

      compositeCtx.save();
      compositeCtx.setTransform(1, 0, 0, 1, 0, 0);
      compositeCtx.fillStyle = 'black';
      compositeCtx.fillRect(0, 0, w, h);

      compositeCtx.scale(dpr, dpr);

      let s = 1;
      let tx = 0;
      let ty = 0;

      if (zoomRect) {
        const r = zoomRect;
        const sZoom = Math.max(Wcss / r.w, Hcss / r.h);
        const cx = r.x + r.w / 2;
        const cy = r.y + r.h / 2;
        const CwX = Wcss / 2;
        const CwY = Hcss / 2;
        tx = CwX - sZoom * cx;
        ty = CwY - sZoom * cy;
        s = sZoom;
      }

      compositeCtx.translate(tx, ty);
      compositeCtx.scale(s, s);

      const s0 = Math.max(Wcss / vw, Hcss / vh);
      const vsW = vw * s0;
      const vsH = vh * s0;
      const dx = (Wcss - vsW) / 2;
      const dy = (Hcss - vsH) / 2;

      compositeCtx.save();
      compositeCtx.filter = videoFilterString || 'none';

      let drawTx = dx;
      let drawTy = dy;
      let scaleX = 1;
      let scaleY = 1;
      if (flipH) {
        drawTx = dx + vsW;
        scaleX = -1;
      }
      if (flipV) {
        drawTy = dy + vsH;
        scaleY = -1;
      }

      compositeCtx.translate(drawTx, drawTy);
      compositeCtx.scale(scaleX, scaleY);
      compositeCtx.scale(s0, s0);

      compositeCtx.drawImage(video, 0, 0, vw, vh);

      compositeCtx.restore();

      compositeCtx.drawImage(
        drawCanvas,
        0, 0, drawCanvas.width, drawCanvas.height,
        0, 0, Wcss, Hcss
      );

      compositeCtx.restore();

      drawStickersToCtx(compositeCtx);

      postProcessFrame();
    }

    /* ===== é™æ­¢ç”»æ’®å½± ===== */
    btnShot.addEventListener('click', () => {
      drawCompositeFrame();
      const url = compositeCanvas.toDataURL('image/png');
      const a = document.createElement('a');
      const ts = new Date().toISOString().replace(/[:.]/g, '-');
      a.href = url;
      a.download = `snapshot_${ts}.png`;
      a.click();
      log('é™æ­¢ç”»ã‚’PNGã¨ã—ã¦ä¿å­˜ã—ã¾ã—ãŸï¼ˆæ˜ åƒè¨­å®šãƒ»åè»¢ãƒ»ã‚ºãƒ¼ãƒ ãƒ»æ‰‹æããƒ»ã‚¹ãƒ†ãƒƒã‚«ãƒ¼ã‚’åæ˜ ï¼‰');
    });

    /* ===== éŒ²ç”» ===== */
    btnStartRec.addEventListener('click', () => {
      if (!cameraStream) {
        log('å…ˆã«ã‚«ãƒ¡ãƒ©ã‚’é–‹å§‹ã—ã¦ãã ã•ã„');
        return;
      }
      if (!supportsMediaRecorder || !supportsCaptureStream) {
        log('ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã§ã¯éŒ²ç”»æ©Ÿèƒ½ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“ï¼ˆiPhone Safari ã®ä¸€éƒ¨ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãªã©ï¼‰ã€‚é™æ­¢ç”»ã¯åˆ©ç”¨å¯èƒ½ã§ã™ã€‚');
        return;
      }

      const fps = Number(videoFpsInput.value) || 30;
      const stream = compositeCanvas.captureStream(fps);

      if (audioEnabled && cameraStream) {
        cameraStream.getAudioTracks().forEach(t => {
          t.enabled = true;
          stream.addTrack(t);
        });
      } else if (cameraStream) {
        cameraStream.getAudioTracks().forEach(t => t.enabled = false);
      }

      recorder = new MediaRecorder(stream, { mimeType: 'video/webm' });
      recordedChunks = [];
      recordingMode = 'normal';

      recorder.ondataavailable = (e) => {
        if (e.data.size > 0) recordedChunks.push(e.data);
      };
      recorder.onstop = () => {
        const blob = new Blob(recordedChunks, { type: 'video/webm' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        const ts = new Date().toISOString().replace(/[:.]/g, '-');
        a.href = url;
        a.download = `record_normal_${ts}.webm`;
        a.click();
        log(`é€šå¸¸å‹•ç”»(WebM, éŸ³å£°${audioEnabled ? 'ã‚ã‚Š' : 'ãªã—'})ã‚’ä¿å­˜ã—ã¾ã—ãŸ`);
      };

      const render = () => {
        drawCompositeFrame();
        animationId = requestAnimationFrame(render);
      };
      render();

      recorder.start();
      btnStartRec.disabled = true;
      btnStopRec.disabled = false;
      btnStartTl.disabled = true;
      startRecTimer();
      log(`é€šå¸¸éŒ²ç”»é–‹å§‹ (FPS: ${fps}, ã‚ºãƒ¼ãƒ : ${zoomRect ? 'ON' : 'OFF'}, éŸ³å£°${audioEnabled ? 'ON' : 'OFF'})`);
    });

    btnStopRec.addEventListener('click', () => {
      if (!recorder || recordingMode !== 'normal') return;
      recorder.stop();
      cancelAnimationFrame(animationId);
      animationId = null;
      btnStartRec.disabled = false;
      btnStopRec.disabled = true;
      btnStartTl.disabled = false;
      stopRecTimer();
      log('é€šå¸¸éŒ²ç”»åœæ­¢');
    });

    btnStartTl.addEventListener('click', () => {
      if (!cameraStream) {
        log('å…ˆã«ã‚«ãƒ¡ãƒ©ã‚’é–‹å§‹ã—ã¦ãã ã•ã„');
        return;
      }
      if (!supportsMediaRecorder || !supportsCaptureStream) {
        log('ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã§ã¯ã‚¿ã‚¤ãƒ ãƒ©ãƒ—ã‚¹éŒ²ç”»ã¯åˆ©ç”¨ã§ãã¾ã›ã‚“ï¼ˆiPhone Safari ã®ä¸€éƒ¨ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãªã©ï¼‰ã€‚é™æ­¢ç”»ã¯åˆ©ç”¨å¯èƒ½ã§ã™ã€‚');
        return;
      }

      const fps = Number(tlFpsInput.value) || 10;
      tlIntervalMs = Number(tlIntervalInput.value) || 500;

      const stream = compositeCanvas.captureStream(fps);

      if (audioEnabled && cameraStream) {
        cameraStream.getAudioTracks().forEach(t => {
          t.enabled = true;
          stream.addTrack(t);
        });
      } else if (cameraStream) {
        cameraStream.getAudioTracks().forEach(t => t.enabled = false);
      }

      recorder = new MediaRecorder(stream, { mimeType: 'video/webm' });
      recordedChunks = [];
      recordingMode = 'timelapse';
      lastTlTime = performance.now();

      recorder.ondataavailable = (e) => {
        if (e.data.size > 0) recordedChunks.push(e.data);
      };
      recorder.onstop = () => {
        const blob = new Blob(recordedChunks, { type: 'video/webm' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        const ts = new Date().toISOString().replace(/[:.]/g, '-');
        a.href = url;
        a.download = `record_timelapse_${ts}.webm`;
        a.click();
        log(`ã‚¿ã‚¤ãƒ ãƒ©ãƒ—ã‚¹(WebM, éŸ³å£°${audioEnabled ? 'ã‚ã‚Š' : 'ãªã—'})ã‚’ä¿å­˜ã—ã¾ã—ãŸ`);
      };

      const renderTl = (time) => {
        if (time - lastTlTime >= tlIntervalMs) {
          drawCompositeFrame();
          lastTlTime = time;
        }
        animationId = requestAnimationFrame(renderTl);
      };
      animationId = requestAnimationFrame(renderTl);

      recorder.start();
      btnStartTl.disabled = true;
      btnStopTl.disabled = false;
      btnStartRec.disabled = true;
      startTlTimer();
      log(`ã‚¿ã‚¤ãƒ ãƒ©ãƒ—ã‚¹éŒ²ç”»é–‹å§‹ (éŒ²ç”»FPS: ${fps}, é–“éš”: ${tlIntervalMs}ms, ã‚ºãƒ¼ãƒ : ${zoomRect ? 'ON' : 'OFF'}, éŸ³å£°${audioEnabled ? 'ON' : 'OFF'})`);
    });

    btnStopTl.addEventListener('click', () => {
      if (!recorder || recordingMode !== 'timelapse') return;
      recorder.stop();
      cancelAnimationFrame(animationId);
      animationId = null;
      btnStartTl.disabled = false;
      btnStopTl.disabled = true;
      btnStartRec.disabled = false;
      stopTlTimer();
      log('ã‚¿ã‚¤ãƒ ãƒ©ãƒ—ã‚¹éŒ²ç”»åœæ­¢');
    });

    /* ===== ã‚ºãƒ¼ãƒ  ===== */
    function updateZoomTransform() {
      if (!zoomRect) {
        cameraInner.style.transform = 'translate(0px, 0px) scale(1)';
        return;
      }
      const W = cameraWrapper.clientWidth;
      const H = cameraWrapper.clientHeight;
      if (!W || !H) return;

      const r = zoomRect;
      const s = Math.max(W / r.w, H / r.h);

      const cx = r.x + r.w / 2;
      const cy = r.y + r.h / 2;
      const CwX = W / 2;
      const CwY = H / 2;

      const tx = CwX - s * cx;
      const ty = CwY - s * cy;

      cameraInner.style.transform = `translate(${tx}px, ${ty}px) scale(${s})`;
    }

    function clearUiCanvas() {
      uiCtx.clearRect(0, 0, uiCanvas.width, uiCanvas.height);
      if (stickers.length) redrawStickerOverlay(false);
    }

    function enterZoomMode() {
      zoomMode = true;
      zoomDragStart = null;
      lastZoomPos = null;
      clearUiCanvas();
      zoomHint.classList.add('visible');
      drawCanvas.style.pointerEvents = 'none';
      log('ã‚ºãƒ¼ãƒ é ˜åŸŸé¸æŠãƒ¢ãƒ¼ãƒ‰ï¼šæ˜ åƒä¸Šã‚’ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ãã ã•ã„');
    }

    function exitZoomMode() {
      zoomMode = false;
      zoomDragStart = null;
      lastZoomPos = null;
      clearUiCanvas();
      zoomHint.classList.remove('visible');
      drawCanvas.style.pointerEvents = 'auto';
    }

    btnZoomSelect.addEventListener('click', () => {
      if (!video.videoWidth) {
        log('ã‚«ãƒ¡ãƒ©èµ·å‹•å¾Œã«ã‚ºãƒ¼ãƒ ã§ãã¾ã™');
        return;
      }
      enterZoomMode();
    });

    btnZoomReset.addEventListener('click', () => {
      zoomRect = null;
      updateZoomTransform();
      exitZoomMode();
      log('ã‚ºãƒ¼ãƒ ã‚’è§£é™¤ã—ã¾ã—ãŸ');
    });

    function drawZoomRectPreview(currentPos) {
      const start = zoomDragStart;
      clearUiCanvas();
      uiCtx.strokeStyle = '#00ff88';
      uiCtx.lineWidth = 2;
      uiCtx.setLineDash([6, 4]);

      const rect = cameraWrapper.getBoundingClientRect();
      const scaleX = uiCanvas.width / rect.width;
      const scaleY = uiCanvas.height / rect.height;

      const x = Math.min(start.x, currentPos.x) * scaleX;
      const y = Math.min(start.y, currentPos.y) * scaleY;
      const w = Math.abs(currentPos.x - start.x) * scaleX;
      const h = Math.abs(currentPos.y - start.y) * scaleY;

      uiCtx.strokeRect(x, y, w, h);
      uiCtx.setLineDash([]);

      if (stickers.length) redrawStickerOverlay(false);
    }

    function finalizeZoom(endPosMaybe) {
      const endPos = endPosMaybe || lastZoomPos || zoomDragStart;
      if (!zoomDragStart || !endPos) {
        clearUiCanvas();
        log('ã‚ºãƒ¼ãƒ ç¯„å›²ãŒæ±ºå®šã§ãã¾ã›ã‚“ã§ã—ãŸã€‚ã‚‚ã†ä¸€åº¦ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ãã ã•ã„ã€‚');
        return;
      }

      const x0 = zoomDragStart.x;
      const y0 = zoomDragStart.y;
      const x1 = endPos.x;
      const y1 = endPos.y;
      const rx = Math.min(x0, x1);
      const ry = Math.min(y0, y1);
      const rw = Math.abs(x1 - x0);
      const rh = Math.abs(y1 - y0);

      const minSize = 20;
      if (rw < minSize || rh < minSize) {
        clearUiCanvas();
        log('é¸æŠç¯„å›²ãŒå°ã•ã™ãã¾ã™ã€‚ã‚‚ã†ä¸€åº¦åºƒã‚ã«ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ãã ã•ã„ã€‚');
        return;
      }

      const W = cameraWrapper.clientWidth;
      const H = cameraWrapper.clientHeight;
      const rxClamped = Math.max(0, Math.min(rx, W));
      const ryClamped = Math.max(0, Math.min(ry, H));
      const rwClamped = Math.min(rw, W - rxClamped);
      const rhClamped = Math.min(rh, H - ryClamped);

      zoomRect = { x: rxClamped, y: ryClamped, w: rwClamped, h: rhClamped };
      updateZoomTransform();
      exitZoomMode();
      log('ã‚ºãƒ¼ãƒ ã‚’é©ç”¨ã—ã¾ã—ãŸï¼ˆéŒ²ç”»ãƒ»TLã‚‚ã“ã®ç¯„å›²ã‚’ä¿å­˜ï¼‰');
    }

    cameraWrapper.addEventListener('mousedown', (e) => {
      if (!zoomMode) return;
      e.preventDefault();
      const pos = getWrapperPosFromClient(e.clientX, e.clientY);
      zoomDragStart = pos;
      lastZoomPos = pos;
    }, { capture: true });
    cameraWrapper.addEventListener('mousemove', (e) => {
      if (!zoomMode || !zoomDragStart) return;
      e.preventDefault();
      const pos = getWrapperPosFromClient(e.clientX, e.clientY);
      lastZoomPos = pos;
      drawZoomRectPreview(pos);
    }, { capture: true });
    cameraWrapper.addEventListener('mouseup', (e) => {
      if (!zoomMode || !zoomDragStart) return;
      e.preventDefault();
      const pos = getWrapperPosFromClient(e.clientX, e.clientY);
      lastZoomPos = pos;
      finalizeZoom(pos);
    }, { capture: true });

    cameraWrapper.addEventListener('touchstart', (e) => {
      if (!zoomMode) return;
      e.preventDefault();
      const t = e.touches[0];
      const pos = getWrapperPosFromClient(t.clientX, t.clientY);
      zoomDragStart = pos;
      lastZoomPos = pos;
    }, { passive: false, capture: true });
    cameraWrapper.addEventListener('touchmove', (e) => {
      if (!zoomMode || !zoomDragStart) return;
      e.preventDefault();
      const t = e.touches[0];
      const pos = getWrapperPosFromClient(t.clientX, t.clientY);
      lastZoomPos = pos;
      drawZoomRectPreview(pos);
    }, { passive: false, capture: true });
    cameraWrapper.addEventListener('touchend', (e) => {
      if (!zoomMode || !zoomDragStart) return;
      e.preventDefault();
      finalizeZoom(null);
    }, { passive: false, capture: true });

    /* ===== ãªã’ãªã‚ãƒœã‚¿ãƒ³ ===== */
    lassoBtn.addEventListener('click', () => {
      lassoMode = !lassoMode;
      isLassoDrawing = false;
      lassoPath = [];

      if (lassoMode) {
        eyedropperMode = false;
        eyedropperBtn.style.borderColor = 'rgba(255,255,255,0.3)';
        uiCanvas.style.pointerEvents = 'auto';
        lassoBtn.style.borderColor = 'rgba(0,200,255,0.9)';
        log('ãªã’ãªã‚ãƒ¢ãƒ¼ãƒ‰: æ˜ åƒä¸Šã‚’ãã‚‹ã£ã¨å›²ã‚“ã§ãã ã•ã„ï¼ˆæŒ‡ã‚’é›¢ã™ã¨åˆ‡ã‚Šå‡ºã—ã¾ã™ï¼‰');
      } else {
        lassoBtn.style.borderColor = 'rgba(255,255,255,0.3)';
        if (stickers.length) {
          uiCanvas.style.pointerEvents = 'auto';
          redrawStickerOverlay(true);
        } else {
          uiCanvas.style.pointerEvents = 'none';
          uiCtx.clearRect(0, 0, uiCanvas.width, uiCanvas.height);
        }
        log('ãªã’ãªã‚ãƒ¢ãƒ¼ãƒ‰: OFF');
      }
    });

    /* ===== ãªã’ãªã‚ï¼†ã‚¹ãƒ†ãƒƒã‚«ãƒ¼æ“ä½œï¼ˆuiCanvasï¼‰ï¼‹ ãƒšãƒ³è£œåŠ© ===== */
    function uiPointerDown(e) {
      if (zoomMode) return;
      const pos = getUiCanvasPos(e);

      // 1. ã‚¹ãƒ†ãƒƒã‚«ãƒ¼ã®ãƒ’ãƒƒãƒˆãƒ†ã‚¹ãƒˆ
      if (stickers.length) {
        for (let i = stickers.length - 1; i >= 0; i--) {
          const st = stickers[i];
          const local = getStickerLocalCoords(st, pos.x, pos.y);
          const w = st.w;
          const h = st.h;

          // ãƒãƒ³ãƒ‰ãƒ«
          const hx = w / 2 + 16;
          const hy = -h / 2 - 16;
          const hr = 12;
          const dxh = local.x - hx;
          const dyh = local.y - hy;
          const distHandle = Math.sqrt(dxh * dxh + dyh * dyh);

          if (distHandle <= hr) {
            activeStickerIndex = i;
            showStickerControls = true;
            stickerDrag.active = true;
            stickerDrag.mode = 'rotate';
            stickerDrag.startX = st.x;
            stickerDrag.startY = st.y;
            stickerDrag.startScale = st.scale;
            stickerDrag.startRotation = st.rotation;
            stickerDrag.startPointerX = pos.x;
            stickerDrag.startPointerY = pos.y;

            const dx0 = pos.x - st.x;
            const dy0 = pos.y - st.y;
            stickerDrag.startDist = Math.sqrt(dx0 * dx0 + dy0 * dy0) || 1;
            stickerDrag.startAngle = Math.atan2(dy0, dx0);

            redrawStickerOverlay(true);
            e.preventDefault();
            return;
          }

          // æœ¬ä½“
          if (local.x >= -w / 2 && local.x <= w / 2 &&
              local.y >= -h / 2 && local.y <= h / 2) {
            activeStickerIndex = i;
            showStickerControls = true;
            stickerDrag.active = true;
            stickerDrag.mode = 'move';
            stickerDrag.startX = st.x;
            stickerDrag.startY = st.y;
            stickerDrag.startPointerX = pos.x;
            stickerDrag.startPointerY = pos.y;
            redrawStickerOverlay(true);
            e.preventDefault();
            return;
          }
        }
      }

      // 2. ãªã’ãªã‚
      if (lassoMode) {
        isLassoDrawing = true;
        lassoPath = [{ x: pos.x, y: pos.y }];
        uiCtx.clearRect(0, 0, uiCanvas.width, uiCanvas.height);
        if (stickers.length) redrawStickerOverlay(false);

        uiCtx.save();
        uiCtx.strokeStyle = '#ffdd00';
        uiCtx.lineWidth = 2;
        uiCtx.setLineDash([4, 3]);
        uiCtx.beginPath();
        uiCtx.moveTo(pos.x, pos.y);
        uiCtx.stroke();
        uiCtx.restore();
        e.preventDefault();
        return;
      }

      // 3. ãã‚Œä»¥å¤– â†’ ãƒšãƒ³æç”»
      showStickerControls = false;
      if (stickers.length) {
        uiCtx.clearRect(0, 0, uiCanvas.width, uiCanvas.height);
        redrawStickerOverlay(false);
      }
      startDraw(e);
    }

    function uiPointerMove(e) {
      if (zoomMode) return;
      const pos = getUiCanvasPos(e);

      // ã‚¹ãƒ†ãƒƒã‚«ãƒ¼ãƒ‰ãƒ©ãƒƒã‚°ä¸­
      if (stickerDrag.active && activeStickerIndex >= 0) {
        const st = stickers[activeStickerIndex];
        e.preventDefault();
        if (stickerDrag.mode === 'move') {
          const dx = pos.x - stickerDrag.startPointerX;
          const dy = pos.y - stickerDrag.startPointerY;
          st.x = stickerDrag.startX + dx;
          st.y = stickerDrag.startY + dy;
        } else if (stickerDrag.mode === 'rotate') {
          const dx = pos.x - st.x;
          const dy = pos.y - st.y;
          const dist = Math.sqrt(dx * dx + dy * dy) || 1;
          const angle = Math.atan2(dy, dx);
          const deltaAngle = angle - stickerDrag.startAngle;
          st.rotation = stickerDrag.startRotation + deltaAngle;
          st.scale = Math.max(0.2, stickerDrag.startScale * (dist / stickerDrag.startDist));
        }
        redrawStickerOverlay(true);
        return;
      }

      // ãªã’ãªã‚æç”»ä¸­
      if (lassoMode && isLassoDrawing) {
        e.preventDefault();
        lassoPath.push({ x: pos.x, y: pos.y });
        uiCtx.clearRect(0, 0, uiCanvas.width, uiCanvas.height);
        if (stickers.length) redrawStickerOverlay(false);

        uiCtx.save();
        uiCtx.strokeStyle = '#ffdd00';
        uiCtx.lineWidth = 2;
        uiCtx.setLineDash([4, 3]);
        uiCtx.beginPath();
        const first = lassoPath[0];
        uiCtx.moveTo(first.x, first.y);
        for (let i = 1; i < lassoPath.length; i++) {
          uiCtx.lineTo(lassoPath[i].x, lassoPath[i].y);
        }
        uiCtx.stroke();
        uiCtx.restore();
        return;
      }

      // ãƒšãƒ³
      if (isDrawing) {
        draw(e);
      }
    }

    function uiPointerUp(e) {
      if (zoomMode) return;

      if (stickerDrag.active) {
        stickerDrag.active = false;
        stickerDrag.mode = null;
        e.preventDefault();
        return;
      }

      if (lassoMode && isLassoDrawing) {
        isLassoDrawing = false;
        e.preventDefault();
        createStickerFromLasso();
        return;
      }

      if (isDrawing) {
        endDraw(e);
      }
    }

    // ãªã’ãªã‚ â†’ ã‚¹ãƒ†ãƒƒã‚«ãƒ¼ä½œæˆ
    function createStickerFromLasso() {
      if (!video.videoWidth) {
        log('ã‚«ãƒ¡ãƒ©èµ·å‹•å¾Œã«ãªã’ãªã‚åˆ‡ã‚Šå‡ºã—ãŒã§ãã¾ã™');
        uiCtx.clearRect(0, 0, uiCanvas.width, uiCanvas.height);
        if (stickers.length) redrawStickerOverlay(false);
        return;
      }
      if (!lassoPath || lassoPath.length < 10) {
        uiCtx.clearRect(0, 0, uiCanvas.width, uiCanvas.height);
        if (stickers.length) redrawStickerOverlay(false);
        log('ãªã’ãªã‚ã®ç·šãŒçŸ­ã™ãã¾ã™ã€‚ã‚‚ã†å°‘ã—å¤§ããå›²ã£ã¦ãã ã•ã„ã€‚');
        return;
      }

      drawCompositeFrame();

      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      for (const p of lassoPath) {
        if (p.x < minX) minX = p.x;
        if (p.y < minY) minY = p.y;
        if (p.x > maxX) maxX = p.x;
        if (p.y > maxY) maxY = p.y;
      }
      const pad = 4;
      minX = Math.max(0, minX - pad);
      minY = Math.max(0, minY - pad);
      maxX = Math.min(uiCanvas.width, maxX + pad);
      maxY = Math.min(uiCanvas.height, maxY + pad);

      const bw = Math.max(1, Math.round(maxX - minX));
      const bh = Math.max(1, Math.round(maxY - minY));

      const stickerCanvas = document.createElement('canvas');
      stickerCanvas.width = bw;
      stickerCanvas.height = bh;
      const sctx = stickerCanvas.getContext('2d');
      sctx.imageSmoothingEnabled = true;

      sctx.save();
      sctx.translate(-minX, -minY);
      sctx.beginPath();
      const first = lassoPath[0];
      sctx.moveTo(first.x, first.y);
      for (let i = 1; i < lassoPath.length; i++) {
        sctx.lineTo(lassoPath[i].x, lassoPath[i].y);
      }
      sctx.closePath();
      sctx.clip();

      sctx.drawImage(compositeCanvas, 0, 0);
      sctx.restore();

      const st = {
        canvas: stickerCanvas,
        w: bw,
        h: bh,
        x: (minX + maxX) / 2,
        y: (minY + maxY) / 2,
        scale: 1,
        rotation: 0
      };
      stickers.push(st);
      activeStickerIndex = stickers.length - 1;
      showStickerControls = true;

      lassoPath = [];
      lassoMode = false;
      lassoBtn.style.borderColor = 'rgba(255,255,255,0.3)';

      uiCanvas.style.pointerEvents = 'auto';
      uiCtx.clearRect(0, 0, uiCanvas.width, uiCanvas.height);
      redrawStickerOverlay(false);

      log('ãªã’ãªã‚ã§æ˜ åƒã‹ã‚‰åˆ‡ã‚Šå‡ºã—ã¾ã—ãŸã€‚ä¸­å¤®ã‚’ãƒ‰ãƒ©ãƒƒã‚°ã§ç§»å‹•ã€å³ä¸Šã®ä¸¸ãƒãƒ³ãƒ‰ãƒ«ã§å›è»¢ï¼‹æ‹¡å¤§ç¸®å°ã§ãã¾ã™ï¼ˆè¤‡æ•°æšé…ç½®å¯èƒ½ï¼‰ã€‚');
    }

    uiCanvas.addEventListener('mousedown', uiPointerDown);
    uiCanvas.addEventListener('mousemove', uiPointerMove);
    uiCanvas.addEventListener('mouseup', uiPointerUp);
    uiCanvas.addEventListener('mouseleave', uiPointerUp);

    uiCanvas.addEventListener('touchstart', uiPointerDown, { passive: false });
    uiCanvas.addEventListener('touchmove', uiPointerMove, { passive: false });
    uiCanvas.addEventListener('touchend', uiPointerUp, { passive: false });
    uiCanvas.addEventListener('touchcancel', uiPointerUp, { passive: false });

    /* ===== ã‚¹ãƒ†ãƒƒã‚«ãƒ¼ä¿å­˜ï¼èª­è¾¼ï¼å‰Šé™¤ ===== */
    stickerSaveBtn.addEventListener('click', () => {
      if (!stickers.length) {
        log('ä¿å­˜ã™ã‚‹ã‚¹ãƒ†ãƒƒã‚«ãƒ¼ãŒã‚ã‚Šã¾ã›ã‚“');
        return;
      }
      const data = stickers.map(st => ({
        img: st.canvas.toDataURL('image/png'),
        x: st.x,
        y: st.y,
        scale: st.scale,
        rotation: st.rotation
      }));
      const blob = new Blob([JSON.stringify({ stickers: data }, null, 2)], {
        type: 'application/json'
      });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      const ts = new Date().toISOString().replace(/[:.]/g, '-');
      a.href = url;
      a.download = `stickers_${ts}.json`;
      a.click();
      URL.revokeObjectURL(url);
      log('ã‚¹ãƒ†ãƒƒã‚«ãƒ¼é…ç½®ã‚’JSONã¨ã—ã¦ä¿å­˜ã—ã¾ã—ãŸ');
    });

    stickerLoadBtn.addEventListener('click', () => {
      stickerFileInput.click();
    });

    stickerFileInput.addEventListener('change', (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        try {
          const json = JSON.parse(ev.target.result);
          if (!json || !Array.isArray(json.stickers)) {
            log('JSONã®å½¢å¼ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“ï¼ˆstickersé…åˆ—ãŒå¿…è¦ã§ã™ï¼‰');
            return;
          }
          const items = json.stickers;
          const promises = items.map(item => {
            return new Promise(resolve => {
              const img = new Image();
              img.onload = () => {
                const c = document.createElement('canvas');
                c.width = img.width;
                c.height = img.height;
                const cctx = c.getContext('2d');
                cctx.drawImage(img, 0, 0);
                resolve({
                  canvas: c,
                  w: c.width,
                  h: c.height,
                  x: item.x,
                  y: item.y,
                  scale: item.scale ?? 1,
                  rotation: item.rotation ?? 0
                });
              };
              img.src = item.img;
            });
          });

          Promise.all(promises).then(list => {
            const before = stickers.length;
            stickers = stickers.concat(list);
            activeStickerIndex = stickers.length ? stickers.length - 1 : -1;
            showStickerControls = true;
            uiCanvas.style.pointerEvents = stickers.length ? 'auto' : 'none';
            uiCtx.clearRect(0, 0, uiCanvas.width, uiCanvas.height);
            redrawStickerOverlay(false);
            log(`ã‚¹ãƒ†ãƒƒã‚«ãƒ¼ã‚’${list.length}æšèª­ã¿è¾¼ã¿ã¾ã—ãŸï¼ˆåˆè¨ˆ ${stickers.length}æšï¼‰ã€‚`);
          });
        } catch (err) {
          console.error(err);
          log('JSONã®èª­ã¿è¾¼ã¿ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
        }
      };
      reader.readAsText(file);
      e.target.value = '';
    });

    stickerDeleteBtn.addEventListener('click', () => {
      if (activeStickerIndex < 0 || activeStickerIndex >= stickers.length) {
        log('å‰Šé™¤ã™ã‚‹ã‚¹ãƒ†ãƒƒã‚«ãƒ¼ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“');
        return;
      }
      stickers.splice(activeStickerIndex, 1);
      if (!stickers.length) {
        activeStickerIndex = -1;
        showStickerControls = false;
        uiCanvas.style.pointerEvents = lassoMode ? 'auto' : 'none';
        uiCtx.clearRect(0, 0, uiCanvas.width, uiCanvas.height);
        log('ã‚¹ãƒ†ãƒƒã‚«ãƒ¼ã‚’ã™ã¹ã¦å‰Šé™¤ã—ã¾ã—ãŸ');
      } else {
        activeStickerIndex = Math.min(activeStickerIndex, stickers.length - 1);
        uiCtx.clearRect(0, 0, uiCanvas.width, uiCanvas.height);
        redrawStickerOverlay(false);
        log('é¸æŠä¸­ã®ã‚¹ãƒ†ãƒƒã‚«ãƒ¼ã‚’å‰Šé™¤ã—ã¾ã—ãŸ');
      }
    });
  </script>
</body>
</html>
